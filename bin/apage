#!/usr/bin/env node

/*! apage CLI 0.0.15 //// MIT Licence //// http://apage.richplastow.com/ */

var shared = {};




/**
 * marked - a markdown parser
 * Copyright (c) 2011-2014, Christopher Jeffrey. (MIT Licensed)
 * https://github.com/chjj/marked
 */

;(function() {

/**
 * Block-Level Grammar
 */

var block = {
  newline: /^\n+/,
  code: /^( {4}[^\n]+\n*)+/,
  fences: noop,
  hr: /^( *[-*_]){3,} *(?:\n+|$)/,
  heading: /^ *(#{1,6}) *([^\n]+?) *#* *(?:\n+|$)/,
  nptable: noop,
  lheading: /^([^\n]+)\n *(=|-){2,} *(?:\n+|$)/,
  blockquote: /^( *>[^\n]+(\n(?!def)[^\n]+)*\n*)+/,
  list: /^( *)(bull) [\s\S]+?(?:hr|def|\n{2,}(?! )(?!\1bull )\n*|\s*$)/,
  html: /^ *(?:comment *(?:\n|\s*$)|closed *(?:\n{2,}|\s*$)|closing *(?:\n{2,}|\s*$))/,
  def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +["(]([^\n]+)[")])? *(?:\n+|$)/,
  table: noop,
  paragraph: /^((?:[^\n]+\n?(?!hr|heading|lheading|blockquote|tag|def))+)\n*/,
  text: /^[^\n]+/
};

block.bullet = /(?:[*+-]|\d+\.)/;
block.item = /^( *)(bull) [^\n]*(?:\n(?!\1bull )[^\n]*)*/;
block.item = replace(block.item, 'gm')
  (/bull/g, block.bullet)
  ();

block.list = replace(block.list)
  (/bull/g, block.bullet)
  ('hr', '\\n+(?=\\1?(?:[-*_] *){3,}(?:\\n+|$))')
  ('def', '\\n+(?=' + block.def.source + ')')
  ();

block.blockquote = replace(block.blockquote)
  ('def', block.def)
  ();

block._tag = '(?!(?:'
  + 'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code'
  + '|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo'
  + '|span|br|wbr|ins|del|img)\\b)\\w+(?!:/|[^\\w\\s@]*@)\\b';

block.html = replace(block.html)
  ('comment', /<!--[\s\S]*?-->/)
  ('closed', /<(tag)[\s\S]+?<\/\1>/)
  ('closing', /<tag(?:"[^"]*"|'[^']*'|[^'">])*?>/)
  (/tag/g, block._tag)
  ();

block.paragraph = replace(block.paragraph)
  ('hr', block.hr)
  ('heading', block.heading)
  ('lheading', block.lheading)
  ('blockquote', block.blockquote)
  ('tag', '<' + block._tag)
  ('def', block.def)
  ();

/**
 * Normal Block Grammar
 */

block.normal = merge({}, block);

/**
 * GFM Block Grammar
 */

block.gfm = merge({}, block.normal, {
  fences: /^ *(`{3,}|~{3,}) *(\S+)? *\n([\s\S]+?)\s*\1 *(?:\n+|$)/,
  paragraph: /^/
});

block.gfm.paragraph = replace(block.paragraph)
  ('(?!', '(?!'
    + block.gfm.fences.source.replace('\\1', '\\2') + '|'
    + block.list.source.replace('\\1', '\\3') + '|')
  ();

/**
 * GFM + Tables Block Grammar
 */

block.tables = merge({}, block.gfm, {
  nptable: /^ *(\S.*\|.*)\n *([-:]+ *\|[-| :]*)\n((?:.*\|.*(?:\n|$))*)\n*/,
  table: /^ *\|(.+)\n *\|( *[-:]+[-| :]*)\n((?: *\|.*(?:\n|$))*)\n*/
});

/**
 * Block Lexer
 */

function Lexer(options) {
  this.tokens = [];
  this.tokens.links = {};
  this.options = options || marked.defaults;
  this.rules = block.normal;

  if (this.options.gfm) {
    if (this.options.tables) {
      this.rules = block.tables;
    } else {
      this.rules = block.gfm;
    }
  }
}

/**
 * Expose Block Rules
 */

Lexer.rules = block;

/**
 * Static Lex Method
 */

Lexer.lex = function(src, options) {
  var lexer = new Lexer(options);
  return lexer.lex(src);
};

/**
 * Preprocessing
 */

Lexer.prototype.lex = function(src) {
  src = src
    .replace(/\r\n|\r/g, '\n')
    .replace(/\t/g, '    ')
    .replace(/\u00a0/g, ' ')
    .replace(/\u2424/g, '\n');

  return this.token(src, true);
};

/**
 * Lexing
 */

Lexer.prototype.token = function(src, top, bq) {
  var src = src.replace(/^ +$/gm, '')
    , next
    , loose
    , cap
    , bull
    , b
    , item
    , space
    , i
    , l;

  while (src) {
    // newline
    if (cap = this.rules.newline.exec(src)) {
      src = src.substring(cap[0].length);
      if (cap[0].length > 1) {
        this.tokens.push({
          type: 'space'
        });
      }
    }

    // code
    if (cap = this.rules.code.exec(src)) {
      src = src.substring(cap[0].length);
      cap = cap[0].replace(/^ {4}/gm, '');
      this.tokens.push({
        type: 'code',
        text: !this.options.pedantic
          ? cap.replace(/\n+$/, '')
          : cap
      });
      continue;
    }

    // fences (gfm)
    if (cap = this.rules.fences.exec(src)) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'code',
        lang: cap[2],
        text: cap[3]
      });
      continue;
    }

    // heading
    if (cap = this.rules.heading.exec(src)) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'heading',
        depth: cap[1].length,
        text: cap[2]
      });
      continue;
    }

    // table no leading pipe (gfm)
    if (top && (cap = this.rules.nptable.exec(src))) {
      src = src.substring(cap[0].length);

      item = {
        type: 'table',
        header: cap[1].replace(/^ *| *\| *$/g, '').split(/ *\| */),
        align: cap[2].replace(/^ *|\| *$/g, '').split(/ *\| */),
        cells: cap[3].replace(/\n$/, '').split('\n')
      };

      for (i = 0; i < item.align.length; i++) {
        if (/^ *-+: *$/.test(item.align[i])) {
          item.align[i] = 'right';
        } else if (/^ *:-+: *$/.test(item.align[i])) {
          item.align[i] = 'center';
        } else if (/^ *:-+ *$/.test(item.align[i])) {
          item.align[i] = 'left';
        } else {
          item.align[i] = null;
        }
      }

      for (i = 0; i < item.cells.length; i++) {
        item.cells[i] = item.cells[i].split(/ *\| */);
      }

      this.tokens.push(item);

      continue;
    }

    // lheading
    if (cap = this.rules.lheading.exec(src)) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'heading',
        depth: cap[2] === '=' ? 1 : 2,
        text: cap[1]
      });
      continue;
    }

    // hr
    if (cap = this.rules.hr.exec(src)) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'hr'
      });
      continue;
    }

    // blockquote
    if (cap = this.rules.blockquote.exec(src)) {
      src = src.substring(cap[0].length);

      this.tokens.push({
        type: 'blockquote_start'
      });

      cap = cap[0].replace(/^ *> ?/gm, '');

      // Pass `top` to keep the current
      // "toplevel" state. This is exactly
      // how markdown.pl works.
      this.token(cap, top, true);

      this.tokens.push({
        type: 'blockquote_end'
      });

      continue;
    }

    // list
    if (cap = this.rules.list.exec(src)) {
      src = src.substring(cap[0].length);
      bull = cap[2];

      this.tokens.push({
        type: 'list_start',
        ordered: bull.length > 1
      });

      // Get each top-level item.
      cap = cap[0].match(this.rules.item);

      next = false;
      l = cap.length;
      i = 0;

      for (; i < l; i++) {
        item = cap[i];

        // Remove the list item's bullet
        // so it is seen as the next token.
        space = item.length;
        item = item.replace(/^ *([*+-]|\d+\.) +/, '');

        // Outdent whatever the
        // list item contains. Hacky.
        if (~item.indexOf('\n ')) {
          space -= item.length;
          item = !this.options.pedantic
            ? item.replace(new RegExp('^ {1,' + space + '}', 'gm'), '')
            : item.replace(/^ {1,4}/gm, '');
        }

        // Determine whether the next list item belongs here.
        // Backpedal if it does not belong in this list.
        if (this.options.smartLists && i !== l - 1) {
          b = block.bullet.exec(cap[i + 1])[0];
          if (bull !== b && !(bull.length > 1 && b.length > 1)) {
            src = cap.slice(i + 1).join('\n') + src;
            i = l - 1;
          }
        }

        // Determine whether item is loose or not.
        // Use: /(^|\n)(?! )[^\n]+\n\n(?!\s*$)/
        // for discount behavior.
        loose = next || /\n\n(?!\s*$)/.test(item);
        if (i !== l - 1) {
          next = item.charAt(item.length - 1) === '\n';
          if (!loose) loose = next;
        }

        this.tokens.push({
          type: loose
            ? 'loose_item_start'
            : 'list_item_start'
        });

        // Recurse.
        this.token(item, false, bq);

        this.tokens.push({
          type: 'list_item_end'
        });
      }

      this.tokens.push({
        type: 'list_end'
      });

      continue;
    }

    // html
    if (cap = this.rules.html.exec(src)) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: this.options.sanitize
          ? 'paragraph'
          : 'html',
        pre: cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style',
        text: cap[0]
      });
      continue;
    }

    // def
    if ((!bq && top) && (cap = this.rules.def.exec(src))) {
      src = src.substring(cap[0].length);
      this.tokens.links[cap[1].toLowerCase()] = {
        href: cap[2],
        title: cap[3]
      };
      continue;
    }

    // table (gfm)
    if (top && (cap = this.rules.table.exec(src))) {
      src = src.substring(cap[0].length);

      item = {
        type: 'table',
        header: cap[1].replace(/^ *| *\| *$/g, '').split(/ *\| */),
        align: cap[2].replace(/^ *|\| *$/g, '').split(/ *\| */),
        cells: cap[3].replace(/(?: *\| *)?\n$/, '').split('\n')
      };

      for (i = 0; i < item.align.length; i++) {
        if (/^ *-+: *$/.test(item.align[i])) {
          item.align[i] = 'right';
        } else if (/^ *:-+: *$/.test(item.align[i])) {
          item.align[i] = 'center';
        } else if (/^ *:-+ *$/.test(item.align[i])) {
          item.align[i] = 'left';
        } else {
          item.align[i] = null;
        }
      }

      for (i = 0; i < item.cells.length; i++) {
        item.cells[i] = item.cells[i]
          .replace(/^ *\| *| *\| *$/g, '')
          .split(/ *\| */);
      }

      this.tokens.push(item);

      continue;
    }

    // top-level paragraph
    if (top && (cap = this.rules.paragraph.exec(src))) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'paragraph',
        text: cap[1].charAt(cap[1].length - 1) === '\n'
          ? cap[1].slice(0, -1)
          : cap[1]
      });
      continue;
    }

    // text
    if (cap = this.rules.text.exec(src)) {
      // Top-level should never reach here.
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'text',
        text: cap[0]
      });
      continue;
    }

    if (src) {
      throw new
        Error('Infinite loop on byte: ' + src.charCodeAt(0));
    }
  }

  return this.tokens;
};

/**
 * Inline-Level Grammar
 */

var inline = {
  escape: /^\\([\\`*{}\[\]()#+\-.!_>])/,
  autolink: /^<([^ >]+(@|:\/)[^ >]+)>/,
  url: noop,
  tag: /^<!--[\s\S]*?-->|^<\/?\w+(?:"[^"]*"|'[^']*'|[^'">])*?>/,
  link: /^!?\[(inside)\]\(href\)/,
  reflink: /^!?\[(inside)\]\s*\[([^\]]*)\]/,
  nolink: /^!?\[((?:\[[^\]]*\]|[^\[\]])*)\]/,
  strong: /^__([\s\S]+?)__(?!_)|^\*\*([\s\S]+?)\*\*(?!\*)/,
  em: /^\b_((?:__|[\s\S])+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,
  code: /^(`+)\s*([\s\S]*?[^`])\s*\1(?!`)/,
  br: /^ {2,}\n(?!\s*$)/,
  del: noop,
  text: /^[\s\S]+?(?=[\\<!\[_*`]| {2,}\n|$)/
};

inline._inside = /(?:\[[^\]]*\]|[^\[\]]|\](?=[^\[]*\]))*/;
inline._href = /\s*<?([\s\S]*?)>?(?:\s+['"]([\s\S]*?)['"])?\s*/;

inline.link = replace(inline.link)
  ('inside', inline._inside)
  ('href', inline._href)
  ();

inline.reflink = replace(inline.reflink)
  ('inside', inline._inside)
  ();

/**
 * Normal Inline Grammar
 */

inline.normal = merge({}, inline);

/**
 * Pedantic Inline Grammar
 */

inline.pedantic = merge({}, inline.normal, {
  strong: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,
  em: /^_(?=\S)([\s\S]*?\S)_(?!_)|^\*(?=\S)([\s\S]*?\S)\*(?!\*)/
});

/**
 * GFM Inline Grammar
 */

inline.gfm = merge({}, inline.normal, {
  escape: replace(inline.escape)('])', '~|])')(),
  url: /^(https?:\/\/[^\s<]+[^<.,:;"')\]\s])/,
  del: /^~~(?=\S)([\s\S]*?\S)~~/,
  text: replace(inline.text)
    (']|', '~]|')
    ('|', '|https?://|')
    ()
});

/**
 * GFM + Line Breaks Inline Grammar
 */

inline.breaks = merge({}, inline.gfm, {
  br: replace(inline.br)('{2,}', '*')(),
  text: replace(inline.gfm.text)('{2,}', '*')()
});

/**
 * Inline Lexer & Compiler
 */

function InlineLexer(links, options) {
  this.options = options || marked.defaults;
  this.links = links;
  this.rules = inline.normal;
  this.renderer = this.options.renderer || new Renderer;
  this.renderer.options = this.options;

  if (!this.links) {
    throw new
      Error('Tokens array requires a `links` property.');
  }

  if (this.options.gfm) {
    if (this.options.breaks) {
      this.rules = inline.breaks;
    } else {
      this.rules = inline.gfm;
    }
  } else if (this.options.pedantic) {
    this.rules = inline.pedantic;
  }
}

/**
 * Expose Inline Rules
 */

InlineLexer.rules = inline;

/**
 * Static Lexing/Compiling Method
 */

InlineLexer.output = function(src, links, options) {
  var inline = new InlineLexer(links, options);
  return inline.output(src);
};

/**
 * Lexing/Compiling
 */

InlineLexer.prototype.output = function(src) {
  var out = ''
    , link
    , text
    , href
    , cap;

  while (src) {
    // escape
    if (cap = this.rules.escape.exec(src)) {
      src = src.substring(cap[0].length);
      out += cap[1];
      continue;
    }

    // autolink
    if (cap = this.rules.autolink.exec(src)) {
      src = src.substring(cap[0].length);
      if (cap[2] === '@') {
        text = cap[1].charAt(6) === ':'
          ? this.mangle(cap[1].substring(7))
          : this.mangle(cap[1]);
        href = this.mangle('mailto:') + text;
      } else {
        text = escape(cap[1]);
        href = text;
      }
      out += this.renderer.link(href, null, text);
      continue;
    }

    // url (gfm)
    if (!this.inLink && (cap = this.rules.url.exec(src))) {
      src = src.substring(cap[0].length);
      text = escape(cap[1]);
      href = text;
      out += this.renderer.link(href, null, text);
      continue;
    }

    // tag
    if (cap = this.rules.tag.exec(src)) {
      if (!this.inLink && /^<a /i.test(cap[0])) {
        this.inLink = true;
      } else if (this.inLink && /^<\/a>/i.test(cap[0])) {
        this.inLink = false;
      }
      src = src.substring(cap[0].length);
      out += this.options.sanitize
        ? escape(cap[0])
        : cap[0];
      continue;
    }

    // link
    if (cap = this.rules.link.exec(src)) {
      src = src.substring(cap[0].length);
      this.inLink = true;
      out += this.outputLink(cap, {
        href: cap[2],
        title: cap[3]
      });
      this.inLink = false;
      continue;
    }

    // reflink, nolink
    if ((cap = this.rules.reflink.exec(src))
        || (cap = this.rules.nolink.exec(src))) {
      src = src.substring(cap[0].length);
      link = (cap[2] || cap[1]).replace(/\s+/g, ' ');
      link = this.links[link.toLowerCase()];
      if (!link || !link.href) {
        out += cap[0].charAt(0);
        src = cap[0].substring(1) + src;
        continue;
      }
      this.inLink = true;
      out += this.outputLink(cap, link);
      this.inLink = false;
      continue;
    }

    // strong
    if (cap = this.rules.strong.exec(src)) {
      src = src.substring(cap[0].length);
      out += this.renderer.strong(this.output(cap[2] || cap[1]));
      continue;
    }

    // em
    if (cap = this.rules.em.exec(src)) {
      src = src.substring(cap[0].length);
      out += this.renderer.em(this.output(cap[2] || cap[1]));
      continue;
    }

    // code
    if (cap = this.rules.code.exec(src)) {
      src = src.substring(cap[0].length);
      out += this.renderer.codespan(escape(cap[2], true));
      continue;
    }

    // br
    if (cap = this.rules.br.exec(src)) {
      src = src.substring(cap[0].length);
      out += this.renderer.br();
      continue;
    }

    // del (gfm)
    if (cap = this.rules.del.exec(src)) {
      src = src.substring(cap[0].length);
      out += this.renderer.del(this.output(cap[1]));
      continue;
    }

    // text
    if (cap = this.rules.text.exec(src)) {
      src = src.substring(cap[0].length);
      out += escape(this.smartypants(cap[0]));
      continue;
    }

    if (src) {
      throw new
        Error('Infinite loop on byte: ' + src.charCodeAt(0));
    }
  }

  return out;
};

/**
 * Compile Link
 */

InlineLexer.prototype.outputLink = function(cap, link) {
  var href = escape(link.href)
    , title = link.title ? escape(link.title) : null;

  return cap[0].charAt(0) !== '!'
    ? this.renderer.link(href, title, this.output(cap[1]))
    : this.renderer.image(href, title, escape(cap[1]));
};

/**
 * Smartypants Transformations
 */

InlineLexer.prototype.smartypants = function(text) {
  if (!this.options.smartypants) return text;
  return text
    // em-dashes
    .replace(/--/g, '\u2014')
    // opening singles
    .replace(/(^|[-\u2014/(\[{"\s])'/g, '$1\u2018')
    // closing singles & apostrophes
    .replace(/'/g, '\u2019')
    // opening doubles
    .replace(/(^|[-\u2014/(\[{\u2018\s])"/g, '$1\u201c')
    // closing doubles
    .replace(/"/g, '\u201d')
    // ellipses
    .replace(/\.{3}/g, '\u2026');
};

/**
 * Mangle Links
 */

InlineLexer.prototype.mangle = function(text) {
  var out = ''
    , l = text.length
    , i = 0
    , ch;

  for (; i < l; i++) {
    ch = text.charCodeAt(i);
    if (Math.random() > 0.5) {
      ch = 'x' + ch.toString(16);
    }
    out += '&#' + ch + ';';
  }

  return out;
};

/**
 * Renderer
 */

function Renderer(options) {
  this.options = options || {};
}

Renderer.prototype.code = function(code, lang, escaped) {
  if (this.options.highlight) {
    var out = this.options.highlight(code, lang);
    if (out != null && out !== code) {
      escaped = true;
      code = out;
    }
  }

  if (!lang) {
    return '<pre><code>'
      + (escaped ? code : escape(code, true))
      + '\n</code></pre>';
  }

  return '<pre><code class="'
    + this.options.langPrefix
    + escape(lang, true)
    + '">'
    + (escaped ? code : escape(code, true))
    + '\n</code></pre>\n';
};

Renderer.prototype.blockquote = function(quote) {
  return '<blockquote>\n' + quote + '</blockquote>\n';
};

Renderer.prototype.html = function(html) {
  return html;
};

Renderer.prototype.heading = function(text, level, raw) {
  return '<h'
    + level
    + ' id="'
    + this.options.headerPrefix
    + raw.toLowerCase().replace(/[^\w]+/g, '-')
    + '">'
    + text
    + '</h'
    + level
    + '>\n';
};

Renderer.prototype.hr = function() {
  return this.options.xhtml ? '<hr/>\n' : '<hr>\n';
};

Renderer.prototype.list = function(body, ordered) {
  var type = ordered ? 'ol' : 'ul';
  return '<' + type + '>\n' + body + '</' + type + '>\n';
};

Renderer.prototype.listitem = function(text) {
  return '<li>' + text + '</li>\n';
};

Renderer.prototype.paragraph = function(text) {
  return '<p>' + text + '</p>\n';
};

Renderer.prototype.table = function(header, body) {
  return '<table>\n'
    + '<thead>\n'
    + header
    + '</thead>\n'
    + '<tbody>\n'
    + body
    + '</tbody>\n'
    + '</table>\n';
};

Renderer.prototype.tablerow = function(content) {
  return '<tr>\n' + content + '</tr>\n';
};

Renderer.prototype.tablecell = function(content, flags) {
  var type = flags.header ? 'th' : 'td';
  var tag = flags.align
    ? '<' + type + ' style="text-align:' + flags.align + '">'
    : '<' + type + '>';
  return tag + content + '</' + type + '>\n';
};

// span level renderer
Renderer.prototype.strong = function(text) {
  return '<strong>' + text + '</strong>';
};

Renderer.prototype.em = function(text) {
  return '<em>' + text + '</em>';
};

Renderer.prototype.codespan = function(text) {
  return '<code>' + text + '</code>';
};

Renderer.prototype.br = function() {
  return this.options.xhtml ? '<br/>' : '<br>';
};

Renderer.prototype.del = function(text) {
  return '<del>' + text + '</del>';
};

Renderer.prototype.link = function(href, title, text) {
  if (this.options.sanitize) {
    try {
      var prot = decodeURIComponent(unescape(href))
        .replace(/[^\w:]/g, '')
        .toLowerCase();
    } catch (e) {
      return '';
    }
    if (prot.indexOf('javascript:') === 0 || prot.indexOf('vbscript:') === 0) {
      return '';
    }
  }
  var out = '<a href="' + href + '"';
  if (title) {
    out += ' title="' + title + '"';
  }
  out += '>' + text + '</a>';
  return out;
};

Renderer.prototype.image = function(href, title, text) {
  var out = '<img src="' + href + '" alt="' + text + '"';
  if (title) {
    out += ' title="' + title + '"';
  }
  out += this.options.xhtml ? '/>' : '>';
  return out;
};

/**
 * Parsing & Compiling
 */

function Parser(options) {
  this.tokens = [];
  this.token = null;
  this.options = options || marked.defaults;
  this.options.renderer = this.options.renderer || new Renderer;
  this.renderer = this.options.renderer;
  this.renderer.options = this.options;
}

/**
 * Static Parse Method
 */

Parser.parse = function(src, options, renderer) {
  var parser = new Parser(options, renderer);
  return parser.parse(src);
};

/**
 * Parse Loop
 */

Parser.prototype.parse = function(src) {
  this.inline = new InlineLexer(src.links, this.options, this.renderer);
  this.tokens = src.reverse();

  var out = '';
  while (this.next()) {
    out += this.tok();
  }

  return out;
};

/**
 * Next Token
 */

Parser.prototype.next = function() {
  return this.token = this.tokens.pop();
};

/**
 * Preview Next Token
 */

Parser.prototype.peek = function() {
  return this.tokens[this.tokens.length - 1] || 0;
};

/**
 * Parse Text Tokens
 */

Parser.prototype.parseText = function() {
  var body = this.token.text;

  while (this.peek().type === 'text') {
    body += '\n' + this.next().text;
  }

  return this.inline.output(body);
};

/**
 * Parse Current Token
 */

Parser.prototype.tok = function() {
  switch (this.token.type) {
    case 'space': {
      return '';
    }
    case 'hr': {
      return this.renderer.hr();
    }
    case 'heading': {
      return this.renderer.heading(
        this.inline.output(this.token.text),
        this.token.depth,
        this.token.text);
    }
    case 'code': {
      return this.renderer.code(this.token.text,
        this.token.lang,
        this.token.escaped);
    }
    case 'table': {
      var header = ''
        , body = ''
        , i
        , row
        , cell
        , flags
        , j;

      // header
      cell = '';
      for (i = 0; i < this.token.header.length; i++) {
        flags = { header: true, align: this.token.align[i] };
        cell += this.renderer.tablecell(
          this.inline.output(this.token.header[i]),
          { header: true, align: this.token.align[i] }
        );
      }
      header += this.renderer.tablerow(cell);

      for (i = 0; i < this.token.cells.length; i++) {
        row = this.token.cells[i];

        cell = '';
        for (j = 0; j < row.length; j++) {
          cell += this.renderer.tablecell(
            this.inline.output(row[j]),
            { header: false, align: this.token.align[j] }
          );
        }

        body += this.renderer.tablerow(cell);
      }
      return this.renderer.table(header, body);
    }
    case 'blockquote_start': {
      var body = '';

      while (this.next().type !== 'blockquote_end') {
        body += this.tok();
      }

      return this.renderer.blockquote(body);
    }
    case 'list_start': {
      var body = ''
        , ordered = this.token.ordered;

      while (this.next().type !== 'list_end') {
        body += this.tok();
      }

      return this.renderer.list(body, ordered);
    }
    case 'list_item_start': {
      var body = '';

      while (this.next().type !== 'list_item_end') {
        body += this.token.type === 'text'
          ? this.parseText()
          : this.tok();
      }

      return this.renderer.listitem(body);
    }
    case 'loose_item_start': {
      var body = '';

      while (this.next().type !== 'list_item_end') {
        body += this.tok();
      }

      return this.renderer.listitem(body);
    }
    case 'html': {
      var html = !this.token.pre && !this.options.pedantic
        ? this.inline.output(this.token.text)
        : this.token.text;
      return this.renderer.html(html);
    }
    case 'paragraph': {
      return this.renderer.paragraph(this.inline.output(this.token.text));
    }
    case 'text': {
      return this.renderer.paragraph(this.parseText());
    }
  }
};

/**
 * Helpers
 */

function escape(html, encode) {
  return html
    .replace(!encode ? /&(?!#?\w+;)/g : /&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#39;');
}

function unescape(html) {
  return html.replace(/&([#\w]+);/g, function(_, n) {
    n = n.toLowerCase();
    if (n === 'colon') return ':';
    if (n.charAt(0) === '#') {
      return n.charAt(1) === 'x'
        ? String.fromCharCode(parseInt(n.substring(2), 16))
        : String.fromCharCode(+n.substring(1));
    }
    return '';
  });
}

function replace(regex, opt) {
  regex = regex.source;
  opt = opt || '';
  return function self(name, val) {
    if (!name) return new RegExp(regex, opt);
    val = val.source || val;
    val = val.replace(/(^|[^\[])\^/g, '$1');
    regex = regex.replace(name, val);
    return self;
  };
}

function noop() {}
noop.exec = noop;

function merge(obj) {
  var i = 1
    , target
    , key;

  for (; i < arguments.length; i++) {
    target = arguments[i];
    for (key in target) {
      if (Object.prototype.hasOwnProperty.call(target, key)) {
        obj[key] = target[key];
      }
    }
  }

  return obj;
}


/**
 * Marked
 */

function marked(src, opt, callback) {
  if (callback || typeof opt === 'function') {
    if (!callback) {
      callback = opt;
      opt = null;
    }

    opt = merge({}, marked.defaults, opt || {});

    var highlight = opt.highlight
      , tokens
      , pending
      , i = 0;

    try {
      tokens = Lexer.lex(src, opt)
    } catch (e) {
      return callback(e);
    }

    pending = tokens.length;

    var done = function(err) {
      if (err) {
        opt.highlight = highlight;
        return callback(err);
      }

      var out;

      try {
        out = Parser.parse(tokens, opt);
      } catch (e) {
        err = e;
      }

      opt.highlight = highlight;

      return err
        ? callback(err)
        : callback(null, out);
    };

    if (!highlight || highlight.length < 3) {
      return done();
    }

    delete opt.highlight;

    if (!pending) return done();

    for (; i < tokens.length; i++) {
      (function(token) {
        if (token.type !== 'code') {
          return --pending || done();
        }
        return highlight(token.text, token.lang, function(err, code) {
          if (err) return done(err);
          if (code == null || code === token.text) {
            return --pending || done();
          }
          token.text = code;
          token.escaped = true;
          --pending || done();
        });
      })(tokens[i]);
    }

    return;
  }
  try {
    if (opt) opt = merge({}, marked.defaults, opt);
    return Parser.parse(Lexer.lex(src, opt), opt);
  } catch (e) {
    e.message += '\nPlease report this to https://github.com/chjj/marked.';
    if ((opt || marked.defaults).silent) {
      return '<p>An error occured:</p><pre>'
        + escape(e.message + '', true)
        + '</pre>';
    }
    throw e;
  }
}

/**
 * Options
 */

marked.options =
marked.setOptions = function(opt) {
  merge(marked.defaults, opt);
  return marked;
};

marked.defaults = {
  gfm: true,
  tables: true,
  breaks: false,
  pedantic: false,
  sanitize: false,
  smartLists: false,
  silent: false,
  highlight: null,
  langPrefix: 'lang-',
  smartypants: false,
  headerPrefix: '',
  renderer: new Renderer,
  xhtml: false
};

/**
 * Expose
 */

marked.Parser = Parser;
marked.parser = Parser.parse;

marked.Renderer = Renderer;

marked.Lexer = Lexer;
marked.lexer = Lexer.lex;

marked.InlineLexer = InlineLexer;
marked.inlineLexer = InlineLexer.output;

marked.parse = marked;

// if (typeof module !== 'undefined' && typeof exports === 'object') {
//   module.exports = marked;
// } else if (typeof define === 'function' && define.amd) {
//   define(function() { return marked; });
// } else {
//   this.marked = marked;
// }
shared.marked = marked; // RP qik fix


}).call(function() {
  return this || (typeof window !== 'undefined' ? window : global);
}());




// Generated by CoffeeScript 1.9.2

/*! Apage 0.0.15 //// MIT Licence //// http://apage.richplastow.com/ */

(function() {
  var Article, Main, dirname, filename, filterLine, marked, ordername, page, parseFilename, renderer, script, tidypath, ª, ªA, ªB, ªE, ªF, ªI, ªN, ªO, ªR, ªS, ªU, ªV, ªX, ªclone, ªex, ªhas, ªpopulate, ªretrieve, ªtype,
    slice = [].slice;

  ªI = 'Apage';

  ªV = '0.0.15';

  ªA = 'array';

  ªB = 'boolean';

  ªE = 'error';

  ªF = 'function';

  ªN = 'number';

  ªO = 'object';

  ªR = 'regexp';

  ªS = 'string';

  ªU = 'undefined';

  ªX = 'null';

  ª = console.log.bind(console);

  ªex = function(x, a, b) {
    var pos;
    if (-1 === (pos = a.indexOf(x))) {
      return x;
    } else {
      return b.charAt(pos);
    }
  };

  ªhas = function(h, n, t, f) {
    if (t == null) {
      t = true;
    }
    if (f == null) {
      f = false;
    }
    if (-1 !== h.indexOf(n)) {
      return t;
    } else {
      return f;
    }
  };

  ªtype = function(x) {
    return {}.toString.call(x).match(/\s([a-z|A-Z]+)/)[1].toLowerCase();
  };

  ªretrieve = function(instances, identifier) {
    var instance;
    instance = instances[identifier];
    if (!instance) {
      switch (typeof identifier) {
        case ªS:
          throw new Error("'" + identifier + "' does not exist");
          break;
        case ªN:
          throw new Error("`" + identifier + "` does not exist");
          break;
        case ªU:
          throw new Error("`identifier` is `undefined`");
          break;
        default:
          throw new Error("`identifier` is type '" + (ªtype(identifier)) + "'");
      }
    }
    return instance;
  };

  ªpopulate = function(candidate, subject, rules, updating) {
    var errors, j, k, key, len, len1, rule, test, type, use, value;
    if (ªO !== ªtype(candidate)) {
      return ["`candidate` is type '" + (ªtype(candidate)) + "' not 'object'"];
    }
    errors = [];
    for (j = 0, len = rules.length; j < len; j++) {
      rule = rules[j];
      key = rule[0], use = rule[1], type = rule[2], test = rule[3];
      value = candidate[key];
      if (void 0 === value) {
        if (updating || void 0 !== use) {
          continue;
        } else {
          errors.push("Missing field '" + key + "' is mandatory");
        }
      } else if (type !== ªtype(value)) {
        errors.push("Field '" + key + "' is type '" + (ªtype(value)) + "' not '" + type + "'");
      } else if (!test.test(value)) {
        errors.push("Field '" + key + "' fails " + ('' + test));
      }
    }
    if (errors.length) {
      return errors;
    }
    for (k = 0, len1 = rules.length; k < len1; k++) {
      rule = rules[k];
      key = rule[0], use = rule[1], type = rule[2], test = rule[3];
      value = candidate[key];
      if (void 0 === value) {
        if (void 0 === subject[key]) {
          subject[key] = use;
        }
      } else {
        subject[key] = value;
      }
    }
  };

  ªclone = function(subject, rules) {
    var j, key, len, out, rule;
    out = {};
    for (j = 0, len = rules.length; j < len; j++) {
      rule = rules[j];
      key = ªS === typeof rule ? rule : rule[0];
      out[key] = subject[key];
    }
    return out;
  };

  parseFilename = function(nm, part) {
    var dash, dot, parts;
    if (ªS !== ªtype(nm)) {
      throw new Error("`nm` is " + (ªtype(nm)) + ", not string");
    }
    parts = {};
    dash = nm.indexOf('-');
    dot = nm.indexOf('.');
    if (-1 === dot) {
      nm += '.';
      dot = nm.length - 1;
    }
    if (-1 !== dash && dash < dot) {
      parts.order = nm.substr(0, dash) * 1;
      if (isNaN(parts.order)) {
        dash = -1;
      }
    } else {
      dash = -1;
    }
    parts.title = nm.substr(dash + 1, dot - dash - 1);
    parts.ext = nm.substr(dot + 1);
    parts.slug = parts.title.toLowerCase().replace(/[“”‘’,]/g, '').replace(/[\s–—…·:;]/g, '-').replace(/^-+|-+$/g, '').replace(/-+/g, '-').replace(/[àáäâèéëêìíïîòóöôùúüûñç]/g, function(c) {
      return ªex(c, 'àáäâèéëêìíïîòóöôùúüûñç', 'aaaaeeeeiiiioooouuuunc');
    });
    if (isNaN(parts.order)) {
      parts.order = parts.slug * 1;
    }
    if (isNaN(parts.order)) {
      parts.order = parts.slug;
    }
    if (!part) {
      return parts;
    }
    if (ªU !== ªtype(parts[part])) {
      return parts[part];
    }
    throw new Error("`part` not recognised, use 'order|title|slug|ext'");
  };

  Article = (function() {
    Article.prototype.I = 'Article';

    Article.prototype.toString = function() {
      return "[object " + this.I + "]";
    };

    Article.prototype._rules = {
      config: [['path', void 0, 'string', /^[a-z0-9][-\/a-z0-9]{0,63}\.[.a-z0-9]+$/i], ['raw', '', 'string', /^[^\x00-\x08\x0E-\x1F]{0,10000}$/]],
      properties: [['id', void 0, 'string', /^apage_[-_0-9a-z]{1,10}$/], ['order', void 0, 'string', /^[-_0-9a-z]{1,10}$/]]
    };

    function Article(config) {
      var errors, fname, i, j, key, len, line, ref, ref1, value;
      if (config == null) {
        config = {};
      }
      this._config = {};
      if (errors = ªpopulate(config, this._config, this._rules.config)) {
        throw new Error('Invalid `config`:\n  ' + errors.join('\n  '));
      }
      this.path = this._config.path.replace(/^[.\/]+|[.\/]+$/g, '');
      this.id = (function() {
        var j, len, ref, results;
        ref = this.path.split('/');
        results = [];
        for (i = j = 0, len = ref.length; j < len; i = ++j) {
          fname = ref[i];
          results.push(parseFilename(fname, 'slug'));
        }
        return results;
      }).call(this);
      this.id = 'apage_' + this.id.join('_');
      this.order = parseFilename(fname, 'order');
      this.front = [];
      if ('---\n' === this._config.raw.substr(0, 4)) {
        this._config.raw = this._config.raw.split('---\n');
        ref = this._config.raw[1].split('\n');
        for (i = j = 0, len = ref.length; j < len; i = ++j) {
          line = ref[i];
          ref1 = line.split(':'), key = ref1[0], value = 2 <= ref1.length ? slice.call(ref1, 1) : [];
          key = key != null ? key.replace(/^\s+|\s+$/g, '') : void 0;
          value = value != null ? value.join(':').replace(/^\s+|\s+$/g, '') : void 0;
          if (!key || !value) {
            continue;
          }
          switch (key) {
            case 'id':
              this.id = "apage_" + (value.replace(/^apage_/, ''));
              break;
            case 'order':
              this.order = isNaN(value * 1) ? value : parseInt(value, 10);
              break;
            case 'title':
              this.title = value;
              break;
            default:
              this.front.push([key, value]);
          }
        }
        this._config.raw = (this._config.raw.slice(2)).join('---\n');
      }
      this._config.raw = this._config.raw.replace(/^\s+|\s+$/g, '');
      this.title = this.title || (this._config.raw.split('\n'))[0];
      this.html = (marked(this._config.raw)).replace(/\\/g, '\\\\').split('\n');
      if (errors = ªpopulate(config, this, this._rules.properties, true)) {
        throw new Error('Invalid `config`:\n  ' + errors.join('\n  '));
      }
    }

    Article.prototype.clone = function() {
      return ªclone(this, ['id', 'path', 'order']);
    };

    Article.prototype.destructor = function() {};

    Article.prototype.edit = function(amend) {
      return ªpopulate(amend, this, this._rules.properties, true);
    };

    Article.prototype.config = function(key, value) {
      var obj;
      switch (arguments.length) {
        case 0:
          return ªclone(this._config, this._rules.config);
        case 1:
          switch (ªtype(key)) {
            case ªS:
              return this._config[key];
            case ªO:
              return ªpopulate(key, this._config, this._rules.config, true);
          }
          break;
        case 2:
          obj = {};
          obj[key] = value;
          return this.config(obj);
      }
    };

    return Article;

  })();

  Main = (function() {
    Main.prototype.I = ªI;

    Main.prototype.V = ªV;

    Main.prototype.toString = function() {
      return "[object " + this.I + "]";
    };

    Main.prototype._rules = {
      config: [['title', 'Untitled', 'string', /^[^\x00-\x1F]{1,24}$/], ['url', false, 'string', /^[-:.\/a-z0-9]{1,64}$/], ['plugin', '', 'string', /^[^\x00-\x08\x0E-\x1F]{0,10000}$/]]
    };

    function Main(config) {
      var errors;
      if (config == null) {
        config = {};
      }
      this._config = {};
      this._articles = [];
      if (errors = ªpopulate(config, this._config, this._rules.config)) {
        throw new Error('Invalid `config`:\n  ' + errors.join('\n  '));
      }
    }

    Main.prototype.config = function(key, value) {
      var obj;
      switch (arguments.length) {
        case 0:
          return ªclone(this._config, this._rules.config);
        case 1:
          switch (ªtype(key)) {
            case ªS:
              return this._config[key];
            case ªO:
              return ªpopulate(key, this._config, this._rules.config, true);
          }
          break;
        case 2:
          obj = {};
          obj[key] = value;
          return this.config(obj);
      }
    };

    Main.prototype.browse = function() {
      var a, j, len, ref, results;
      ref = this._articles;
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        a = ref[j];
        results.push((function(a) {
          return {
            id: a.id,
            order: a.order
          };
        })(a));
      }
      return results;
    };

    Main.prototype.read = function(identifier) {
      var art;
      art = ªretrieve(this._articles, identifier);
      return art.clone();
    };

    Main.prototype.destroy = function(identifier) {
      var art;
      art = ªretrieve(this._articles, identifier);
      delete this._articles[art.id];
      this._articles.splice(art.index, 1);
      art.destructor();
      return this;
    };

    Main.prototype.edit = function(identifier, amend) {
      var art, errors;
      art = ªretrieve(this._articles, identifier);
      if (errors = art.edit(amend)) {
        throw new Error('Invalid `amend`:\n  ' + errors.join('\n  '));
      }
      return this;
    };

    Main.prototype.add = function(article) {
      var instance;
      if (!article) {
        return this;
      }
      instance = new Article(article);
      if (this._articles[instance.id]) {
        throw new Error("'" + instance.id + "' already exists");
      }
      instance.index = this._articles.length;
      this._articles.push(instance);
      this._articles.sort(function(a, b) {
        if (a.order > b.order) {
          return 1;
        }
        if (a.order < b.order) {
          return -1;
        }
        if (a.id > b.id) {
          return 1;
        }
        if (a.id < b.id) {
          return -1;
        }
        return 0;
      });
      this._articles[instance.id] = instance;
      return this;
    };

    Main.prototype.render = function() {
      return "" + (page(this._config, this._articles));
    };

    return Main;

  })();

  // if (ªF === typeof define && define.amd) {
  //   define(function() {
  //     return Main;
  //   });
  // } else if (ªO === typeof module && module && module.exports) {
  //   module.exports = Main;
  // } else {
  //   this[ªI] = Main;
  // }
  shared.Apage = Main; // RP qik fix

  // if (ªF === typeof define && define.amd) {

  // } else if (ªO === typeof module && module && module.exports) {
  //   marked = require('marked');
  // } else {
  //   marked = window.marked;
  // }
  marked = shared.marked; // RP qik fix


  renderer = new marked.Renderer;

  renderer.heading = function(text, level) {
    return "<h" + level + ">" + text + "</h" + level + ">\n";
  };

  marked.setOptions({
    renderer: renderer
  });

  page = function(config, articles) {
    var article, comment, generator, i, j, k, len, len1, line, out, ref;
    generator = ªI + " " + ªV + " http://apage.richplastow.com/";
    comment = config.plugin ? '‘Inspect Element’ here, for Apage’s injected CSS' : 'Apage was configured with no plugins, so no CSS is injected here';
    out = ["<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <title>" + config.title + "</title>\n  <meta http-equiv=\"Content-Type\" content=\"text/html;charset=utf-8\">\n  <meta name=\"generator\" content=\"" + generator + "\">\n  <style>\n    /* " + comment + " */\n  </style>\n" + (script(config, articles)) + "\n</head>\n<body>\n"];
    if (!articles.length) {
      out.push('<!-- Apage was rendered with no articles -->\n');
    }
    for (i = j = 0, len = articles.length; j < len; i = ++j) {
      article = articles[i];
      out.push("<article id=\"" + article.id + "\"\n        class=\"apage\"\n  data-apage-opath=\"/" + article.path + "\"\n  data-apage-dname=\"_" + (dirname(article.path)) + "\"\n  data-apage-order=\"" + article.order + "\"\n  data-apage-front='" + ((JSON.stringify(article.front)).replace(/'/g, "&#39;")) + "'\n  data-apage-title=\"" + article.title + "\">");
      ref = article.html;
      for (k = 0, len1 = ref.length; k < len1; k++) {
        line = ref[k];
        out.push(filterLine(config, line));
      }
      out.push("</article><!-- / #" + article.id + " -->\n\n");
    }
    comment = config.plugin ? '‘Inspect Element’ here, for Apage’s injected elements' : 'Apage was configured with no plugins, so nothing is injected here';
    out.push("<!-- " + comment + " -->");
    return out.join('\n  ') + '\n\n</body>\n</html>';
  };

  filterLine = function(config, line) {
    var rx;
    if (config.url) {
      rx = new RegExp('href="' + config.url, 'g');
      return line.replace(rx, 'href="');
    } else {
      return line;
    }
  };

  tidypath = function(p) {
    var name, order;
    name = filename(p).split('-');
    order = name[0];
    name = isNaN(order * 1) ? name.join('-') : name.slice(1).join('-');
    return dirname(p) + name.split('.').slice(0, -1).join('.');
  };

  dirname = function(p) {
    return ªhas(p, '/', p.split('/').slice(0, -1).join('_') + '_', '');
  };

  filename = function(p) {
    return p.split('/').slice(-1)[0];
  };

  ordername = function(p) {
    var order;
    order = filename(p).split('-')[0];
    if (isNaN(order * 1)) {
      return '';
    } else {
      return order * 1;
    }
  };

  script = function(config, articles) {
    if (!config.plugin) {
      return '';
    }
    return "\n  <script>\n\n//// When the DOM is ready, set up Apage and inject the plugins. \nwindow.addEventListener('load', function () { (function (d) { 'use strict'; \n\n\n//// Declare iterator, length and HTML-reference variables. \nvar i, l, $ref\n\n\n//// Initialize two arrays which are available to all Apage plugins. \n ,arts      = []\n ,resolvers = []\n ,updaters  = []\n\n\n//// Like jQuery, but native. \n ,$  = d.querySelector.bind(d)\n ,$$ = d.querySelectorAll.bind(d)\n\n\n//// Get a reference to all `<article class=\"apage\">` elements. \n ,$arts = $$('article.apage')\n\n\n//// Convert JavaScript’s native `arguments` object to an array. \n ,getArgs = function (args, offset) {\n    return Array.prototype.slice.call(args, offset || 0);\n }\n\n\n//// `unattribute($ref,'data-apage-','opath'...)` removes data attributes. \n ,unattribute = function ($ref, prefix) {\n    for ( var i=0, suffs=getArgs(arguments,2), l=suffs.length; i<l; i++ ) {\n      $ref.removeAttribute(prefix + suffs[i]);\n    }\n  }\n\n\n//// Runs each resolver in order. These are added by the plugins, below. \n//// Resolvers are used to map a query to an article. \n ,resolve = function (query) {\n    for (var i=0, l=resolvers.length, backstop, result={}; i<l; i++) {\n      result = resolvers[i](query);\n      if (result.art) { break; } // `query` does resolve to an article\n      backstop = result.backstop || backstop; // may return a backstop\n    }\n    return result.art ? result.art : backstop; //@todo test logic of 'last valid backstop return' with several plugins at once\n  }\n\n\n//// Runs each updater in order. These are added by the plugins, below. \n//// Updaters change the current DOM state, eg to show a single article. \n ,update = function (query) {\n    for (var i=0, l=updaters.length, current=resolve(query); i<l; i++) {\n      updaters[i](current);\n    }\n  }\n\n\n//// Tidies the URL hash and runs `update()` when the URL hash changes. \n ,onHashchange = function (event) {\n    update( window.location.hash.substr(1).replace(/\\//g,'_') );\n    if (event) { event.preventDefault(); }\n  }\n\n;\n\n\n//// Populate the `arts` array using data from Apage `<ARTICLE>` elements. \nfor (i=0, l=$arts.length; i<l; i++) {\n  $ref = $arts[i];\n  arts.push({\n    id:    $ref.getAttribute('id')\n   ,opath: $ref.getAttribute('data-apage-opath')\n   ,dname: $ref.getAttribute('data-apage-dname')\n   ,order: $ref.getAttribute('data-apage-order')\n   ,front: JSON.parse( $ref.getAttribute('data-apage-front') )\n   ,title: $ref.getAttribute('data-apage-title')\n   ,$ref:  $ref\n  });\n  unattribute($ref,'data-apage-','opath','dname','order','front','title');\n}\n\n\n//// Begin injecting plugins. \n\n" + config.plugin + "\n\n//// End injecting plugins. \n\n\n//// Run each updater when the page loads, and when the URL hash changes. \nonHashchange();\nwindow.addEventListener('hashchange', onHashchange);\n\n\n}).call(this, document) });\n\n  </script>\n";
  };

}).call(this);




!function (root) { 'use strict';


    //// Define constants.
    var I     = 'apage'
      , V     = '0.0.15'


    //// Load Node modules and Apage.
      , fs    = require('fs')
      , util  = require('util')
      , Apage = shared.Apage // require('Apage')


    //// Declare and initialize variables.
      , pkg   = {}
      , argv  = process.argv.slice()
      , arg
      , flag = false
      , e
      , i
      , input
      , output
      , inputs = []
      , plugins = []
      , titles = []
      , articles = []
      , articleTally = 0


    //// Usage instructions.
      , help = [
            I + ' ' + V
          , '================================'.substr(0, (I + ' ' + V).length)
          , ''
          , 'Generate a single-page website from multiple markdown sources.'
          , ''
          , ''
          , 'Basic Usage'
          , '-----------'
          , ''
          , I + ' -h'
          , I + ' --version'
          , I + ' -i foo.md bar.md -o foobar.html -p \'alert(arts.length)\''
          , I + ' --title Doc Pages --output index.htm --input doc/*.md'
          , I + ' -o out.htm -i `find . -name \'*.md\'` -p "`cat a.js b.js`"'
          , ''
          , ''
          , 'Options'
          , '-------'
          , ''
          , '-h --help     Show this help.'
          , '-i --input    One or more input files, treated as markdown.'
          , '-o --output   An output HTML file.'
          , '-p --plugin   One or more JavaScript plugins (see below).'
          , '-t --title    The site title (optional, defaults to --output).' //@todo defaults to <H1> of primary markdown file
          , '-v --version  Show the ' + I + ' version.'
          , ''
          , ''
          , 'Plugin Usage'
          , '------------'
          , ''
          , 'Xx. @todo'
          , I + ' -i in.md -o out.html -p \'alert(arts.length)\''
          , I + ' -i in.md -o out.html -p \"`cat build/plugin/*.js`\"'
          , ''
          , ''
        ]


    //// `normalizeArg()` deals with arguments like '--foo=bar' and '-xyz'.
      , normalizeArg = function () {

            // Remove the first argument from `argv`.
            var a = argv.shift();

            // Deal with 'foo', '--' or '-'.
            if ('-' !== a.substr(0, 1) || '--' === a || '-' === a) { return a; }

            // Deal with '--foo', '--foo=bar' or even '--foo=bar=!='.
            if ( '--' === a.substr(0, 2) ) {
                a = a.split('=');
                if (1 < a.length) {
                    argv.unshift( a.slice(1).join('=') ); // reinstate 'bar=!='
                }
                return a[0]; // eg '--foo'
            }

            // No need to process a single argument, eg '-w'.
            if (2 == a.length) { return a; }

            // Deal with '-xyz', which is shorthand for '-x -y -z'.
            argv = a
               .substr(2) // trim the leading '-x'
               .split('') // convert 'yz' to ['y','z']
               .map( function (c) { return '-' + c; } ) // ['-y', '-z']
               .concat(argv) // prepend these elements onto `argv`
            ;
            return a.substr(0, 2); // return '-x'
        }


    //// `exit()` cleanly quits the CLI, eg `return exit(3, "Oops, problems!")`.
      , exit = function (code, message, indent) {
            message = message + ( indent ? ':\n  ' + indent : '' );
            message += ( '\n' === message.slice(-1) ) ? '' : '\n';
            process.stdout.write(message);
            process.exit(code);
        }


    //// `packageField()` retrieves a given field from ‘package.json’.
      , packageField = function (key) {
            if (! pkg.json) {
                try { pkg.json = JSON.parse( fs.readFileSync('package.json') ) }
                catch (e) { exit(1, 'Cannot read and parse package.json', e) }
            }
            return pkg.json[key];
        }


    //// `entitle()` converts a `name` field to a `title`.
      , entitle = function (name) {
            var title = [];
            name.split('-').forEach( function (word) {
                title.push( word[0].toUpperCase() + word.substr(1) );
            });
            return title.join('');
        }


    //// `renderPage()` creates the HTML '--output' file.
      , renderPage = function () {

            //// Get the title, if set, and create an `Apage` instance.
            var
                title  = titles.length  ? titles.join(' ')  : output
              , plugin = plugins.length ? plugins.join('\n') : ''
              , apage = new Apage({
                    title:  title
                  , url:    pkg.homepage
                  , plugin: plugin
                })
              , html
            ;

            //// Append each article to the page.
            for (i=0; i<articleTally; i++) {
                try {
                    apage.add( articles[i] );
                } catch (e) {
                    return exit(3, "Error in '" + articles[i].input + "'", e);
                }
            }

            //// Render the page as an HTML string.
            try {
                html = apage.render();
            } catch (e) {
                return exit(4, 'Error rendering page:', e);
            }

            //// Write the HTML ot the '--output' file.
            fs.writeFile( output, html, 'utf8', function (e) {
                if (e) { return exit(5, "Error writing '" + output + "':", e); }
                exit(0, html.length + " bytes written to '" + output + "'");
            });
        }
    ;


    //// Populate `pkg` with useful values from ‘package.json’
    pkg = { // note that `process.env.npm_package_*` is for `npm run ...` calls
        name:     process.env.npm_package_name     || packageField('name')
      , title:    process.env.npm_package_title    || packageField('title')
      , version:  process.env.npm_package_version  || packageField('version')
      , license:  process.env.npm_package_license  || packageField('license')
      , homepage: process.env.npm_package_homepage || packageField('homepage')
    }


    //// Process each argument.
    argv.splice(0, 2); // ignore 'node' and the path to this file
    while (argv.length) {
        arg = normalizeArg();
        switch (arg) {
            case '-h':
            case '--help':
                return exit( 0, help.join('\n') );
            case '-i':
            case '--input':
                flag = 'input';
                break;
            case '-o':
            case '--output':
                flag = 'output';
                output = argv.shift();
                break;
            case '-p':
            case '--plugin':
                flag = 'plugin';
                break;
            case '-t':
            case '--title':
                flag = 'title';
                break;
            case '-v':
            case '--version':
                return exit(0, V);
            default:
                if (2 === arg.length && '-' === arg[0]) { flag = 'unknown'; }
                else if ('input'  == flag) { inputs.push(arg);  } // an input path
                else if ('plugin' == flag) { plugins.push(arg); } // a plugin path
                else if ('title'  == flag) { titles.push(arg);  } // part of the title
        }
    }


    //// Deal with missing '--input' or '--output' arguments.
    if (0 == inputs.length || ! output) {
        return exit(1, 'Please supply --input file(s) and an --output file');
    }


    //// Populate `articles` with the raw content of each '--input' file.
    for (i in inputs) {
        ( function (i, input) { // closure, preserves `i` in `articles[i] = ...`
            fs.readFile(input, 'utf8', function (e, data) {
                if (e) { return exit(2, "Error reading '" + input + "':", e); }
                articles[i] = { path: input, raw: data };
                if (++articleTally === inputs.length) { renderPage(); }
            });
        }(i, inputs[i]) );
    };


}(this);
